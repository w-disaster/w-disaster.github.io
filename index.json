[{"categories":["crypto"],"content":"ECB oracle","date":"2022-04-07","objectID":"/ecb-oracle/","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - ECB oracle","uri":"/ecb-oracle/"},{"categories":["crypto"],"content":"Description This challenge has been taken from http://aes.cryptohack.org/ecb_oracle/. What we have is an function that concats the FLAG to a plaintext given as parameter and encrypts it through EAS in ECB mode. Here’s chall.py: #!/usr/bin/python3 from flag import FLAG from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import os KEY = os.urandom(16) def encrypt(plaintext): plaintext = plaintext.encode() # concat plaintext with 16 - len(plaintext) bytes # with value 16 - len(plaintext) padded = pad(plaintext + FLAG.encode(), 16) cipher = AES.new(KEY, AES.MODE_ECB) try: encrypted = cipher.encrypt(padded) except ValueError as e: return {\"error\": str(e)} return encrypted.hex() if __name__ == '__main__': while True: plain = input(\"encrypt\u003e \") print(bytes.fromhex(encrypt(plain))) ","date":"2022-04-07","objectID":"/ecb-oracle/:1:0","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - ECB oracle","uri":"/ecb-oracle/"},{"categories":["crypto"],"content":"Exploit Let’s first take a look how AES ECB works: We can state that: The flag is concatenated after the plaintext input; ECB encodes blocks of 16 bytes with the same key; The flag is 26 chars long. The main idea to exploit this bad implementation is to start to encode a string of: $$\\Bigl \\lceil \\dfrac{\\text{flagSize}}{\\text{blockSize}} \\Bigr \\rceil * \\text{blockSize} - 1$$ bytes, so in this case of 31. If we do so, there’s the first char of the flag that gets encrypted in the last byte of the second block. In order to solve this challenge we can brute force this last char and then repeat the process for the remaining characters decreasing the input plaintext. For instance, first plaintext that the oracle encrypts is the following one: $$\\text{Oracle}(\\text{“A”} * 31 + \\text{flag} + \\text{padding}) \\newline= E(\\text{“A”} * 16) + E(\\text{“A”} * 15 + ch_1) + E(ch_2 + … + ch_n + \\text{padding})$$ Proceed finding the next chars decrementing the size of the “A”‘s until the entire flag is known. Exploit.py: import requests from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import os from binascii import hexlify, unhexlify import string from pwn import process p = process(\"./chall.py\") def recvuntil_sendl(p, ustring, payload): p.recvuntil(ustring.encode()) p.sendline(payload.encode()) a = p.recvline().decode() # remove b and '' on the sides of the encrypted text a = a[2:-1] return list(bytes(a, \"utf-8\")) def getflag(p): flag = \"\" for i in range(1, 27): payload = \"A\" * (32 - i) answer = recvuntil_sendl(p, \"encrypt\u003e \", payload) # brute force the char for s in string.printable: bf = payload + flag + s bf_answer = recvuntil_sendl(p, \"encrypt\u003e \", bf) # each hex is two char so compare until 32 * 2 if bf_answer[0:32 * 2] == answer[0:32 * 2]: flag = flag + s break print(flag) getflag(p) p.close() python3 exploit.py [+] Starting local process ‘./chall.py’: pid 38213 flag{4tt3nt1_4d_u54r3_3cb} [*] Stopped process ‘./chall.py’ (pid 38213) ","date":"2022-04-07","objectID":"/ecb-oracle/:2:0","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - ECB oracle","uri":"/ecb-oracle/"},{"categories":["crypto"],"content":"A password has been chosen as AES key","date":"2022-04-07","objectID":"/password-as-keys/","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - Password as keys","uri":"/password-as-keys/"},{"categories":["crypto"],"content":"Description This challenge has been taken from http://aes.cryptohack.org/passwords_as_keys/. The FLAG has been encoded with the AES cipher in ECB mode using as key an hash of a predictable word (a bad password). The website gives us an API through which we can get the encoded flag and it’s also shown where the word has been drawn. Here’s the code: from Crypto.Cipher import AES import hashlib import random # /usr/share/dict/words from # https://gist.githubusercontent.com/wchargin/8927565/raw/d9783627c731268fb2935a731a618aa8e95cf465/words with open(\"/usr/share/dict/words\") as f: words = [w.strip() for w in f.readlines()] keyword = random.choice(words) KEY = hashlib.md5(keyword.encode()).digest() FLAG = ? @chal.route('/passwords_as_keys/decrypt/\u003cciphertext\u003e/\u003cpassword_hash\u003e/') def decrypt(ciphertext, password_hash): ciphertext = bytes.fromhex(ciphertext) key = bytes.fromhex(password_hash) cipher = AES.new(key, AES.MODE_ECB) try: decrypted = cipher.decrypt(ciphertext) except ValueError as e: return {\"error\": str(e)} return {\"plaintext\": decrypted.hex()} @chal.route('/passwords_as_keys/encrypt_flag/') def encrypt_flag(): cipher = AES.new(KEY, AES.MODE_ECB) encrypted = cipher.encrypt(FLAG.encode()) return {\"ciphertext\": encrypted.hex()} ","date":"2022-04-07","objectID":"/password-as-keys/:1:0","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - Password as keys","uri":"/password-as-keys/"},{"categories":["crypto"],"content":"Exploit In order to find the flag first get the encoded FLAG and then brute force the key from the word dict: curl http://aes.cryptohack.org/passwords_as_keys/encrypt_flag/ {“ciphertext”:“c92b7734070205bdf6c0087a751466ec13ae15e6f1bcdd3f3a535ec0f4bbae66”} curl https://gist.githubusercontent.com/wchargin/8927565/raw/d9783627c731268fb2935a731a618aa8e95cf465/words \u003e words.txt from Crypto.Cipher import AES import hashlib import random # AES ECB decrypt def decrypt(ciphertext, password_hash): ciphertext = bytes.fromhex(ciphertext) key = bytes.fromhex(password_hash) cipher = AES.new(key, AES.MODE_ECB) try: decrypted = cipher.decrypt(ciphertext) except ValueError as e: return {\"error\": str(e)} return decrypted.hex() with open(\"words.txt\") as f: words = [w.strip() for w in f.readlines()] if __name__ == '__main__': # Encoded flag enc = \"c92b7734070205bdf6c0087a751466ec13ae15e6f1bcdd3f3a535ec0f4bbae66\" # The flag starts with \"crypto\" plain = ''.join(['{:02x}'.format(ord(c)) for c in \"crypto\"]) # Brute force the key for i in range(len(words)): key = hashlib.md5(words[i].encode()).digest().hex() res = decrypt(enc, key) if plain in res: print(bytearray.fromhex(res).decode()) break crypto{k3y5__r__n07__p455w0rdz?} ","date":"2022-04-07","objectID":"/password-as-keys/:2:0","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - Password as keys","uri":"/password-as-keys/"},{"categories":["crypto"],"content":"A bad implementation of the AES in CBC mode choosed the key as the IV parameter, find the key","date":"2022-04-06","objectID":"/crypto-lazy-cbc/","tags":["crypto","exploit","aes","cbc"],"title":"Crypto - Lazy CBC","uri":"/crypto-lazy-cbc/"},{"categories":["crypto"],"content":"Description A bad implementation of the AES in CBC mode choosed the key as the IV (Initialization Vector) parameter, since it was considered not important to reach the scope. What we have is a python script which encodes every string you insert from stdin and the goal is to find the key e.i. the flag. ","date":"2022-04-06","objectID":"/crypto-lazy-cbc/:1:0","tags":["crypto","exploit","aes","cbc"],"title":"Crypto - Lazy CBC","uri":"/crypto-lazy-cbc/"},{"categories":["crypto"],"content":"Exploit #!/usr/bin/env python3 from Crypto.Cipher import AES from flag import FLAG key = FLAG.encode() def encrypt(plaintext, IV, key): if len(plaintext) % 16 != 0: return \"Input length must be multiple of 16\" plaintext = bytes.fromhex(plaintext) cipher = AES.new(key, AES.MODE_CBC, IV) enc = cipher.encrypt(plaintext) return enc.hex() def decrypt(ciphertext, IV, key): if len(ciphertext) % 16 != 0: return \"Input length must be multiple of 16\" cipher = AES.new(key, AES.MODE_CBC, IV) plain = cipher.decrypt(bytes.fromhex(ciphertext)) return plain.hex() if __name__ == '__main__': while True: print(\"1) Encrypt a message\") print(\"2) Decrypt a massage\") choice = str(input(\"\u003e \")) print(choice.encode()) if choice == \"1\": plain = input(\"enter message\u003e \") enc = encrypt(plain, key, key) print(enc) if choice == \"2\": ciphertext = input(\"enter ciphertext\u003e \") plain = decrypt(ciphertext, key, key) print(plain) Let’s take a look at AES encryption and decription in CBC mode: to solve this challenge we must play with the XOR operator: if in the encryption step we pass as plaintext a string of all zeros (16, the block size), for instance in the first block, the correspondent ciphertext will be the following: $$C_0 = E_0(\\text{IV} \\oplus P_0) = E_0(\\text{IV} \\oplus “0000000000000000”) = E_0(\\text{IV}) $$ because $$(1 \\oplus 0) = 1 \\text{ and } (0 \\oplus 0) = 0$$ Now, that’s the idea: since AES is a simmetric key cipher it uses the same key for the message decryption, so filling the first ciphertext block with all zeros and putting as \\(C_1\\) the \\(C_0\\) just discussed we can determine IV: $$P_1 = (“0000000000000000” \\oplus E_1(C_1)) \\newline = (“0000000000000000” \\oplus \\text{IV}) = \\text{IV}$$ Exploit: import pwn BLK_SIZE = 16 if __name__ == '__main__': p = pwn.process(\"./chall.py\") # Encrypt p.sendline(\"1\".encode()) p.recvuntil(\"enter message\u003e \".encode()) p.sendline(BLK_SIZE * \"00\".encode()) c2 = p.recvline().decode() c1 = \"00\" * BLK_SIZE # Decrypt p.sendline(\"2\".encode()) p.sendline((c1 + c2).encode()) p.recvuntil(\"enter ciphertext\u003e \".encode()) plain = p.recvline().decode() print(bytes.fromhex(str(plain))) p.close() python3 exploit.py [+] Starting local process ‘./chall.py’: pid 68990 b’\\x0cLN\\xd6\\x85\\x07\\xfa?z\\xaf\\xd6\\xf6\\xdea\u003cbflag{b4d_c1ph3r}’ [*] Stopped process ‘./chall.py’ (pid 68990) ","date":"2022-04-06","objectID":"/crypto-lazy-cbc/:2:0","tags":["crypto","exploit","aes","cbc"],"title":"Crypto - Lazy CBC","uri":"/crypto-lazy-cbc/"},{"categories":null,"content":"Me My name is Luca Fabri and I’m 22 y.o. I’m a master degree student at the University of Bologna (Italy). I graduated with a bachelor’s degree in computer science and engineering and I’m currently studying Artificial Intelligence. My interests in computer science also include cybersecurity topics. Contacts  Github: w-disaster  Email: luca.fabri1999@gmail.com  Instagram: luca.fabri ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"About Me","uri":"/about/"}]