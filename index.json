[{"categories":["crypto"],"content":"A password has been chosen as AES key","date":"2022-04-07","objectID":"/password_as_keys/","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - Password as keys","uri":"/password_as_keys/"},{"categories":["crypto"],"content":"Description This challenge has been taken from http://aes.cryptohack.org/passwords_as_keys/. The FLAG has been encoded with the AES cipher in ECB mode using as key an hash of a predictable word (a bad password). The website gives us an API through which we can get the encoded flag and it’s also shown where the word has been drawn. Here’s the code: from Crypto.Cipher import AES import hashlib import random # /usr/share/dict/words from # https://gist.githubusercontent.com/wchargin/8927565/raw/d9783627c731268fb2935a731a618aa8e95cf465/words with open(\"/usr/share/dict/words\") as f: words = [w.strip() for w in f.readlines()] keyword = random.choice(words) KEY = hashlib.md5(keyword.encode()).digest() FLAG = ? @chal.route('/passwords_as_keys/decrypt/\u003cciphertext\u003e/\u003cpassword_hash\u003e/') def decrypt(ciphertext, password_hash): ciphertext = bytes.fromhex(ciphertext) key = bytes.fromhex(password_hash) cipher = AES.new(key, AES.MODE_ECB) try: decrypted = cipher.decrypt(ciphertext) except ValueError as e: return {\"error\": str(e)} return {\"plaintext\": decrypted.hex()} @chal.route('/passwords_as_keys/encrypt_flag/') def encrypt_flag(): cipher = AES.new(KEY, AES.MODE_ECB) encrypted = cipher.encrypt(FLAG.encode()) return {\"ciphertext\": encrypted.hex()} ","date":"2022-04-07","objectID":"/password_as_keys/:1:0","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - Password as keys","uri":"/password_as_keys/"},{"categories":["crypto"],"content":"Exploit In order to find the flag first get the encoded FLAG and then brute force the key from the word dict: curl http://aes.cryptohack.org/passwords_as_keys/encrypt_flag/ {“ciphertext”:“c92b7734070205bdf6c0087a751466ec13ae15e6f1bcdd3f3a535ec0f4bbae66”} curl https://gist.githubusercontent.com/wchargin/8927565/raw/d9783627c731268fb2935a731a618aa8e95cf465/words \u003e words.txt from Crypto.Cipher import AES import hashlib import random # AES ECB decrypt def decrypt(ciphertext, password_hash): ciphertext = bytes.fromhex(ciphertext) key = bytes.fromhex(password_hash) cipher = AES.new(key, AES.MODE_ECB) try: decrypted = cipher.decrypt(ciphertext) except ValueError as e: return {\"error\": str(e)} return decrypted.hex() with open(\"words.txt\") as f: words = [w.strip() for w in f.readlines()] if __name__ == '__main__': # Encoded flag enc = \"c92b7734070205bdf6c0087a751466ec13ae15e6f1bcdd3f3a535ec0f4bbae66\" # The flag starts with \"crypto\" plain = ''.join(['{:02x}'.format(ord(c)) for c in \"crypto\"]) # Brute force the key for i in range(len(words)): key = hashlib.md5(words[i].encode()).digest().hex() res = decrypt(enc, key) if plain in res: print(bytearray.fromhex(res).decode()) break crypto{k3y5__r__n07__p455w0rdz?} ","date":"2022-04-07","objectID":"/password_as_keys/:2:0","tags":["crypto","exploit","aes","ecb"],"title":"Crypto - Password as keys","uri":"/password_as_keys/"},{"categories":["crypto"],"content":"A bad implementation of the AES in CBC mode choosed the key as the IV parameter, find the key","date":"2022-04-06","objectID":"/crypto-lazy-cbc/","tags":["crypto","exploit","aes","cbc"],"title":"Crypto - Lazy CBC","uri":"/crypto-lazy-cbc/"},{"categories":["crypto"],"content":"Description A bad implementation of the AES in CBC mode choosed the key as the IV (Initialization Vector) parameter, since it was considered not important to reach the scope. What we have is a python script which encodes every string you insert from stdin and the goal is to find the key e.i. the flag. ","date":"2022-04-06","objectID":"/crypto-lazy-cbc/:1:0","tags":["crypto","exploit","aes","cbc"],"title":"Crypto - Lazy CBC","uri":"/crypto-lazy-cbc/"},{"categories":["crypto"],"content":"Exploit #!/usr/bin/env python3 from Crypto.Cipher import AES from flag import FLAG key = FLAG.encode() def encrypt(plaintext, IV, key): if len(plaintext) % 16 != 0: return \"Input length must be multiple of 16\" plaintext = bytes.fromhex(plaintext) cipher = AES.new(key, AES.MODE_CBC, IV) enc = cipher.encrypt(plaintext) return enc.hex() def decrypt(ciphertext, IV, key): if len(ciphertext) % 16 != 0: return \"Input length must be multiple of 16\" cipher = AES.new(key, AES.MODE_CBC, IV) plain = cipher.decrypt(bytes.fromhex(ciphertext)) return plain.hex() if __name__ == '__main__': while True: print(\"1) Encrypt a message\") print(\"2) Decrypt a massage\") choice = str(input(\"\u003e \")) print(choice.encode()) if choice == \"1\": plain = input(\"enter message\u003e \") enc = encrypt(plain, key, key) print(enc) if choice == \"2\": ciphertext = input(\"enter ciphertext\u003e \") plain = decrypt(ciphertext, key, key) print(plain) Let’s take a look at AES encryption and decription in CBC mode: to solve this challenge we must play with the XOR operator: if in the encryption step we pass as plaintext a string of all zeros (16, the block size), for instance in the first block, the correspondent ciphertext will be the following: $$C_0 = E_0(\\text{IV} \\oplus P_0) = E_0(\\text{IV} \\oplus “0000000000000000”) = E_0(\\text{IV}) $$ because $$(1 \\oplus 0) = 1 \\text{ and } (0 \\oplus 0) = 0$$ Now, that’s the idea: since AES is a simmetric key cipher it uses the same key for the message decryption, so filling the first ciphertext block with all zeros and putting as \\(C_1\\) the \\(C_0\\) just discussed we can determine IV: $$P_1 = (“0000000000000000” \\oplus E_1(C_1)) \\newline = (“0000000000000000” \\oplus \\text{IV}) = \\text{IV}$$ Exploit: import pwn BLK_SIZE = 16 if __name__ == '__main__': p = pwn.process(\"./chall.py\") # Encrypt p.sendline(\"1\".encode()) p.recvuntil(\"enter message\u003e \".encode()) p.sendline(BLK_SIZE * \"00\".encode()) c2 = p.recvline().decode() c1 = \"00\" * BLK_SIZE # Decrypt p.sendline(\"2\".encode()) p.sendline((c1 + c2).encode()) p.recvuntil(\"enter ciphertext\u003e \".encode()) plain = p.recvline().decode() print(bytes.fromhex(str(plain))) p.close() python3 exploit.py [+] Starting local process ‘./chall.py’: pid 68990 b’\\x0cLN\\xd6\\x85\\x07\\xfa?z\\xaf\\xd6\\xf6\\xdea\u003cbflag{b4d_c1ph3r}’ [*] Stopped process ‘./chall.py’ (pid 68990) ","date":"2022-04-06","objectID":"/crypto-lazy-cbc/:2:0","tags":["crypto","exploit","aes","cbc"],"title":"Crypto - Lazy CBC","uri":"/crypto-lazy-cbc/"},{"categories":null,"content":"Me My name is Luca Fabri and I’m 22 y.o. I’m a master degree student at the University of Bologna (Italy). I graduated with a bachelor’s degree in computer science and engineering and I’m currently studying Artificial Intelligence. My interests in computer science also include cybersecurity topics. Contacts  Github: w-disaster  Email: luca.fabri1999@gmail.com  Instagram: luca.fabri ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"About Me","uri":"/about/"}]